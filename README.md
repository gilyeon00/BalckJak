# 문제

본 프로젝트는 딜러와 플레이어 간의 승부를 겨루는 **블랙잭(Blackjack)** 게임을 변형하여 구현한 콘솔 기반 프로그램입니다. 블랙잭 게임은 딜러와 플레이어 중 카드의 합이 21 또는 21에 가장 가까운 숫자를 가지는 쪽이 이기는 게임입니다 (블랙잭, 플레잉 카드에 대한 사전지식이 부족한 관계로 [블랙잭 나무위키](https://namu.wiki/w/%EB%B8%94%EB%9E%99%EC%9E%AD(%ED%94%8C%EB%A0%88%EC%9E%89%20%EC%B9%B4%EB%93%9C))를 참고했습니다)
# 제시받은 요구사항

- **플레이어는 게임을 시작할 때 베팅 금액을 정해야 한다.**
- 카드의 숫자 계산은 카드 숫자를 기본으로 하며, 예외로 Ace는 1 또는 11로 계산할 수 있으며, King, Queen, Jack은 각각 10으로 계산한다.
- 게임을 시작하면 플레이어는 두 장의 카드를 지급 받으며, 두 장의 카드 숫자를 합쳐 21을 초과하지 않으면서 21에 가깝게 만들면 이긴다.
  21을 넘지 않을 경우 원한다면 얼마든지 카드를 계속 뽑을 수 있다. **단, 카드를 추가로 뽑아 21을 초과할 경우 베팅 금액을 모두 잃게 된다.**
- **처음 두 장의 카드 합이 21일 경우 블랙잭이 되면 베팅 금액의 1.5 배를 딜러에게 받는다. 딜러와 플레이어가 모두 동시에 블랙잭인 경우 플레이어는 베팅한 금액을 돌려받는다.**
- 딜러는 처음에 받은 2장의 합계가 16이하이면 반드시 1장의 카드를 추가로 받아야 하고, 17점 이상이면 추가로 받을 수 없다.
- 딜러가 21을 초과하면 그 시점까지 남아 있던 플레이어들은 가지고 있는 패에 상관 없이 승리해 **베팅 금액을 받는다.**

# 실행 결과 예시

```
  게임에 참여할 사람의 이름을 입력하세요.(쉼표 기준으로 분리)
  pobi,jason
  
  pobi의 배팅 금액은?
  10000
  
  jason의 배팅 금액은?
  20000
  
  딜러와 pobi, jason에게 2장의 나누었습니다.
  딜러: 3다이아몬드
  pobi카드: 2하트, 8스페이드
  jason카드: 7클로버, K스페이드
  
  pobi는 한장의 카드를 더 받겠습니까?(예는 y, 아니오는 n)
  y
  pobi카드: 2하트, 8스페이드, A클로버
  pobi는 한장의 카드를 더 받겠습니까?(예는 y, 아니오는 n)
  n
  jason은 한장의 카드를 더 받겠습니까?(예는 y, 아니오는 n)
  n
  jason카드: 7클로버, K스페이드
  
  딜러는 16이하라 한장의 카드를 더 받았습니다.
  
  딜러 카드: 3다이아몬드, 9클로버, 8다이아몬드 - 결과: 20
  pobi카드: 2하트, 8스페이드, A클로버 - 결과: 21
  jason카드: 7클로버, K스페이드 - 결과: 17
  
  ## 최종 수익
  딜러: 10000
  pobi: 10000
  jason: -20000
```

# 프로그래밍 요구사항

- 모든 기능을 TDD로 구현해 단위 테스트가 존재해야 한다. 단, UI(System.out, System.in) 로직은 제외
- indent(인덴트, 들여쓰기) depth를 2를 넘지 않도록 구현한다. 1까지만 허용한다.
- **모든 엔티티를 작게 유지한다.**
- **3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.**
- **딜러와 플레이어에서 발생하는 중복 코드를 제거해야 한다.**
- 함수(또는 메서드)의 길이가 15라인을 넘어가지 않도록 구현한다.
- 기능을 구현하기 전에 README.md 파일에 구현할 기능 목록을 정리해 추가한다.
- git의 commit 단위는 앞 단계에서 README.md 파일에 정리한 기능 목록 단위로 추가한다.


# 기능 요구사항

- 게임 초기화
- [x]  플레이어는 1 - 6명 까지 “,” (쉼표)를 기준으로 이름을 입력하여 초기화할 수 있다
- [x]  각 플레이어는 베팅 금액을 입력할 수 있다
- [x]  딜러, 플레이어는 각 2장씩 카드를 받는다


- 덱 관리
- [x]  52장의 카드가 있어야한다
  - [x]  하트, 클로버, 스페이드, 다이아  *  1~10 (1은 Ace), Jack, Queen, King
- [x]  카드가 무작위로 섞여있어야한다
- [x]  블랙잭이 아닐경우 추가카드를 받고 싶은 플레이어는 원하는 만큼 추가카드를 받을 수 있다.(턴을 돌아가며)
- [x]  덱에서 카드를 한 장 뽑을 수 있다
  - [x]  카드를 추가로 뽑았을 때 21 초과가 되면 즉시 패한다 (버스트 상태)


- 카드
- [x]  Ace 는 1 또는 11로 계산할 수 있다
- [x]  Jack, Queen, King 은 10으로 계산한다
- [x]  딜러의 카드합이 16이하면 카드 한장을 더 추가한다
- [x]  딜러의 카드합이 21이상이면 남아있는 플레이어는 패에 상관없이 베팅금액을 돌려받는다


- 블랙잭 판별
- [x]  처음 받은 두 카드의 합이 21 일경우
- [x]  플레이어의 처음 받은 카드가 블랙잭이면 본인의 배팅금액의 1.5배를 받는다
- [x]  딜러, 플레이어 모두 처음 받은 카드가 21일 경우 무승부, 각자 모두 베팅한 금액을 돌려받고 종료한다


- 승패에 따른 배팅 금액 분배
> 블랙잭은 딜러와 플레이어 간 **각각 1:1 대결**로 수익을 계산 (딜러가 은행 역할)
- [x]  추가 카드를 다 받았을 경우, 딜러 카드를 오픈하며 승패를 산정한다
- [x]  플레이어가 이기면 본인의 베팅금을 딜러로부터 받는다
- [x]  플레이어가 지면 본인의 베팅금을 잃는다 (딜러가 가져간다)

---

 위의 요구사항들을 추상적으로 요약했을 때 다음과 같은 행위의 반복으로 정의했습니다

1. 덱에서 게이머들(플레이어/딜러)에게 카드를 나눠준다.
2. 지급받은 카드를 룰에 따라 검증은 한다.
3. 블랙잭이 없을 경우 룰에 따라 게이머들은 카드를 한 장씩 더 뽑는다
4. 2-3번을 반복한다

다음과 같이 필요한 객체를 뽑을 수 있습니다.

- 덱 (카드 리스트를 가지고 있음, 카드를 나눠주는 주체)
- 카드 (숫자, 모양을 가지고 있음)
- 게이머 (플레이어, 딜러로 나눌 수 있음)
- 룰 (Ace 1,11 결정, 블랙잭 판별, 승패 판정의 주체)


# 고려한 사항
## Gamer 추상 클래스 설계

`Player`와 `Dealer`는 모두 "카드를 가진 참가자"라는 공통 개념을 기반으로 하기 때문에,

공통 필드와 행위를 담는 `Gamer` abstract class를 설계했습니다.

이 클래스는 다음의 책임을 가집니다:

- 이름, 카드 목록, 보유 금액 등의 공통 상태 보유
- 카드 수령 및 점수 계산 (`receiveCard()`, `calculateScore()`)
- 버스트 여부 판별 (`isBust()`)
- 금액 지불 (`pay()`)

## 버스트 처리 흐름과 예외 설계

### 목표

플레이어나 딜러가 버스트(21 초과) 되었을 때 해당 게이머만 즉시 패배 처리하고, 다른 게이머들과 계속 진행될 수 있도록 설계하는 것이 목표입니다.

### ❌ 초기 접근 (잘못된 가정)

처음에는 "플레이어 중 한 명이라도 버스트가 되면 게임이 즉시 종료된다"고 잘못 이해하여,

버스트가 발생할 때마다 `GamerBustException`을 던지고 `Game.run()` 전체를 종료하는 방식으로 구현했습니다.

```java
java
복사편집
if (player.isBust()) {
    throw new GamerBustException(player); // ❌ 전체 게임 종료
}

```

### 문제 파악 및 개선 방향

블랙잭 룰을 다시 확인한 결과,

> **버스트된 게이머만 패배 처리**되고, 나머지 게임은 그대로 진행되어야 한다는 것을 알게 됐습니다
>

이에 따라 예외를 던지는 대신 플레이어의 생존 여부에 따라 분기 처리하는 방식으로 수정했습니다

처음에는 플레이어중 한 명이라도 버스트 상태가 되면 즉시 게임 종료가 되는 줄 알았으나, 룰을 좀 더 확인해봤을 때 해당 플레이어만 즉시 패배이며, 다른 플레이어가 있을 경우 게임을 그대로 진행한다는 것을 알았습니다.

이전에는 즉시 게임 종료를 시켰기 때문에 해당 플레이어만 패배시키는 구현 변경이 이뤄져야했습니다

### 최종 설계 : **GamerBustException** + 플레이어 분기 처리

- `GamerBustException`은 여전히 `Dealer`가 버스트될 때 사용되며,
  “딜러가 버스트시 플레이어들은 카드 패에 상관없이 즉시 패한다” 는 룰을 준수합니다
- 플레이어는 `partitionPlayersByBust()`에서 Bust 여에 따라 생존/패배로 분리합니다.

### 예외 클래스

```java
public class GamerBustException extends RuntimeException {

    private final Gamer gamer;

    public GamerBustException(Gamer gamer) {
        super(gamer.getName() + "의 카드 합이 21을 초과하여 게임이 종료됩니다.");
        this.gamer = gamer;
    }

    public Gamer getGamer() {
        return gamer;
    }
}

```

### 플레이어 입력 분기 처리

```java
private PlayerPartition partitionPlayersByBust(List<Player> players, Deck deck) {
    List<Player> survived = new ArrayList<>();
    List<Player> busted = new ArrayList<>();

    for (Player player : players) {
        while (true) {
            if (player.isBust()) {
                System.out.println(player.getName() + "의 카드 총합이 21을 초과하여 패배했습니다.");
                busted.add(player);
                break;
            }

            if (!input.askDrawCard(player)) {
                break;
            }

            player.receiveCard(deck.drawCard());
            System.out.println(player.getName() + "카드: " + player.getCards());
        }

        if (!player.isBust()) {
            survived.add(player);
        }
    }

    return new PlayerPartition(survived, busted);
}
```
## 승패 판단 로직 객체지향적 리팩토링 적용

### 리팩토링 목표

- 승자만 자신의 입장에서 승리 처리를 하도록 하여 단일 책임 원칙(SRP)을 따름
- 패자는 결과를 알지 못하고, 승자가 모든 처리를 위임받음
- 객체 간 메시지를 주고받는 방식의 협력 관계로 전환

### 배경

기존의 `Rule.resolve()` 메서드는 Game의 흐름에 따라 승패를 직접 판단합니다
이 방식은 로직이 분산되고 **승자와 패자의 책임이 중복**되어 코드 복잡도와 의존성이 증가하는 문제가 있었습니다.
(휴먼 에러가 날 가능성또한 존재)

```java
for (Player busted : partition.busted()) {
    dealer.winFrom(busted);
    busted.loseFrom(dealer);
}
```

### 리팩토링 후 구조

- `winFrom(Gamer)` 메서드의 추상화

승리 처리 로직은 `Player`와 `Dealer`가 전혀 다르기 때문에, `Gamer` 추상 클래스에는 `winFrom()`을 추상 메서드로 정의하여 구체 클래스에서 반드시 구현하도록 강제했습니다.

```java
public abstract void winFrom(Gamer gamer);
```

➡️ Rule의 resolve()는 오직 승자만 호출되도록 변경

```java
public void resolve(Dealer dealer, PlayerPartition partition) {
    for (Player busted : partition.busted()) {
        dealer.winFrom(busted); // 딜러가 승리
    }

    for (Player player : partition.survived()) {
        if (dealer.isBust()) {
            player.winFrom(dealer); // 딜러 버스트 → 플레이어 승리
        } else {
            int playerScore = player.calculateScore();
            int dealerScore = dealer.calculateScore();

            if (playerScore > dealerScore) {
                player.winFrom(dealer); // 플레이어 승리
            } else if (playerScore < dealerScore) {
                dealer.winFrom(player); // 딜러 승리
            } else {
                player.refund(); // 무승부
            }
        }
    }
}

```

### 객체지향 설계 원칙 적용 및 효과

- 다형성(polymorphism)을 활용하여 `Rule` 또는 `Game`에서는 `gamer.winFrom(gamer)`처럼 일관된 방식으로 호출 가능
- 승자의 관점에서만 처리하도록 통일하여 코드 중복 제거 및 책임 명확
- **SRP**: 승자만 금액 처리 책임을 가지며, 로직이 단일화됨
- **Tell, Don’t Ask**: 승자가 패자의 상태를 묻지 않고 메시지를 보내도록 전환
- **Liskov Substitution**: Gamer 타입을 기반으로 Player/Dealer 자유 교체 가능
- 캡슐화: 금액 변화는 `Money`와 `pay()`를 통해 안전하게 관리 (Money 는 불변 객체)

---
# 테스트 결과
![Image](https://github.com/user-attachments/assets/08e61f1d-0926-48c0-852f-595cc0b42737)

# 실행 결과

- 딜러만 버스트 되는 경우

```java
게임에 참여할 사람의 이름을 입력하세요. (쉼표 기준으로 분리, 1~6명)
aa, bb
aa의 배팅 금액은?
1000
bb의 배팅 금액은?
2000
딜러와 aa, bb에게 2장의 카드를 나누었습니다.

딜러: 2클로버
aa카드: [4하트, A다이아몬드]
bb카드: [10스페이드, Q클로버]

aa는 한 장의 카드를 더 받겠습니까? (예는 y, 아니오는 n)

y 또는 n으로 입력해주세요.
aa는 한 장의 카드를 더 받겠습니까? (예는 y, 아니오는 n)
n
bb는 한 장의 카드를 더 받겠습니까? (예는 y, 아니오는 n)
n
딜러가 카드 한 장을 뽑았습니다
딜러가 카드 한 장을 뽑았습니다
딜러의 카드 합이 21을 넘어 모든 플레이어는 패에 상관없이 베팅금액을 돌려받습니다.
aa은 베팅 금액을 돌려받습니다.
bb은 베팅 금액을 돌려받습니다.

딜러 카드: 2클로버, 4스페이드, 10다이아몬드, K클로버 - 결과: 26
aa카드: 4하트, A다이아몬드 - 결과: 15
bb카드: 10스페이드, Q클로버 - 결과: 20

## 최종 수익
딜러: 0
aa: 0
bb: 0
```

- 모든 플레이어가 버스트 상태이며, 딜러또한 버스트 상태일 경우

```java
게임에 참여할 사람의 이름을 입력하세요. (쉼표 기준으로 분리, 1~6명)
aa,bb
aa의 배팅 금액은?
1000
bb의 배팅 금액은?
2000
딜러와 aa, bb에게 2장의 카드를 나누었습니다.

딜러: 3하트
aa카드: [4다이아몬드, 10다이아몬드]
bb카드: [J하트, 4클로버]

aa는 한 장의 카드를 더 받겠습니까? (예는 y, 아니오는 n)
a
y 또는 n으로 입력해주세요.
aa는 한 장의 카드를 더 받겠습니까? (예는 y, 아니오는 n)
y
aa카드: [4다이아몬드, 10다이아몬드, 9클로버]
aa의 카드 총합이 21을 초과하여 패배했습니다.
bb는 한 장의 카드를 더 받겠습니까? (예는 y, 아니오는 n)
y
bb카드: [J하트, 4클로버, 9하트]
bb의 카드 총합이 21을 초과하여 패배했습니다.
딜러가 카드 한 장을 뽑았습니다
딜러의 카드 합이 21을 넘어 모든 플레이어는 패에 상관없이 베팅금액을 돌려받습니다.
aa은 베팅 금액을 돌려받습니다.
bb은 베팅 금액을 돌려받습니다.

딜러 카드: 3하트, Q스페이드, J클로버 - 결과: 23
aa카드: 4다이아몬드, 10다이아몬드, 9클로버 - 결과: 23
bb카드: J하트, 4클로버, 9하트 - 결과: 23

## 최종 수익
딜러: 0
aa: 0
bb: 0
```

- aa플레이어가 버스트 상태이며, 딜러와 bb플레이어가 무승부인 경우

```java
게임에 참여할 사람의 이름을 입력하세요. (쉼표 기준으로 분리, 1~6명)
aa, bb
aa의 배팅 금액은?
1000
bb의 배팅 금액은?
2000
딜러와 aa, bb에게 2장의 카드를 나누었습니다.

딜러: 6하트
aa카드: [8다이아몬드, 3다이아몬드]
bb카드: [10클로버, J스페이드]

aa는 한 장의 카드를 더 받겠습니까? (예는 y, 아니오는 n)
y
aa카드: [8다이아몬드, 3다이아몬드, 2스페이드]
aa는 한 장의 카드를 더 받겠습니까? (예는 y, 아니오는 n)
y
aa카드: [8다이아몬드, 3다이아몬드, 2스페이드, 10다이아몬드]
aa의 카드 총합이 21을 초과하여 패배했습니다.
bb는 한 장의 카드를 더 받겠습니까? (예는 y, 아니오는 n)
n
딜러가 카드 한 장을 뽑았습니다
bb은 베팅 금액을 돌려받습니다.

딜러 카드: 6하트, 4스페이드, Q다이아몬드 - 결과: 20
aa카드: 8다이아몬드, 3다이아몬드, 2스페이드, 10다이아몬드 - 결과: 23
bb카드: 10클로버, J스페이드 - 결과: 20

## 최종 수익
딜러: 1000
aa: -1000
bb: 0
```

- 딜러가 블랙잭인 경우

```java
게임에 참여할 사람의 이름을 입력하세요. (쉼표 기준으로 분리, 1~6명)
a,b,c
a의 배팅 금액은?
1000
b의 배팅 금액은?
2000
c의 배팅 금액은?
3000
딜러와 a, b, c에게 2장의 카드를 나누었습니다.

딜러: A하트
a카드: [5다이아몬드, J다이아몬드]
b카드: [3스페이드, 10다이아몬드]
c카드: [4다이아몬드, 10스페이드]

딜러 카드: A하트, Q클로버 - 결과: 21
a카드: 5다이아몬드, J다이아몬드 - 결과: 15
b카드: 3스페이드, 10다이아몬드 - 결과: 13
c카드: 4다이아몬드, 10스페이드 - 결과: 14

## 최종 수익
딜러: 6000
a: -1000
b: -2000
c: -3000

```